<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI API ì‚¬ìš©ëŸ‰ ëŒ€ì‹œë³´ë“œ (IndexedDB)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .data-source {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            text-align: center;
        }

        .source-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .source-status {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .source-status.connected {
            background: rgba(34, 197, 94, 0.1);
            color: #16a34a;
        }

        .source-status.disconnected {
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        select, button {
            padding: 10px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .summary-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
            transition: transform 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .summary-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2);
        }

        .summary-card:hover {
            transform: translateY(-5px);
        }

        .card-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .card-value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .card-title {
            color: #666;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .charts-section {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .chart-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .details-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .detail-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .logs-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .logs-table th {
            background: var(--bg-secondary, #f8f9fa);
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #e9ecef;
        }

        .logs-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
        }

        .logs-table tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }

        .feature-list {
            list-style: none;
        }

        .feature-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .feature-item:last-child {
            border-bottom: none;
        }

        .item-name {
            font-weight: 500;
        }

        .item-stats {
            text-align: right;
            font-size: 0.9rem;
            color: #666;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-success {
            background: #22c55e;
        }

        .status-error {
            background: #ef4444;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: white;
            font-size: 1.2rem;
        }

        .error {
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            border-left: 4px solid #ef4444;
        }

        .export-section {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
        }

        .export-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }

        .export-btn {
            padding: 12px 25px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s ease;
        }

        .export-btn:hover {
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
            
            .details-section {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }

        .no-data {
            text-align: center;
            padding: 50px;
            color: #999;
            font-size: 1.2rem;
        }

        .refresh-info {
            font-size: 0.9rem;
            color: #666;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ—„ï¸ AI API ì‚¬ìš©ëŸ‰ ëŒ€ì‹œë³´ë“œ</h1>
            <p>IndexedDB ê¸°ë°˜ ë¡œì»¬ ë°ì´í„° ë¶„ì„</p>
        </div>

        <!-- ë°ì´í„° ì†ŒìŠ¤ ìƒíƒœ -->
        <div class="data-source">
            <div class="source-info">
                <span>ğŸ“Š ë°ì´í„° ì†ŒìŠ¤: IndexedDB</span>
                <span id="connectionStatus" class="source-status disconnected">ì—°ê²° í™•ì¸ ì¤‘...</span>
            </div>
            <div class="refresh-info">
                <span id="lastUpdate">ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: í™•ì¸ ì¤‘...</span>
                <button onclick="loadIndexedDBData()" style="margin-left: 15px;">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
            </div>
        </div>

        <!-- ì»¨íŠ¸ë¡¤ íŒ¨ë„ -->
        <div class="controls" id="controls" style="display: none;">
            <div class="control-group">
                <label>ê¸°ê°„ ìœ í˜•</label>
                <select id="periodType" onchange="updateData()">
                    <option value="daily">ì¼ë³„</option>
                    <option value="weekly">ì£¼ê°„ë³„</option>
                    <option value="monthly">ì›”ê°„ë³„</option>
                </select>
            </div>
            <div class="control-group">
                <label>ë²”ìœ„</label>
                <select id="rangeSelect" onchange="updateData()">
                    <option value="7">ìµœê·¼ 7ì¼</option>
                    <option value="14">ìµœê·¼ 14ì¼</option>
                    <option value="30">ìµœê·¼ 30ì¼</option>
                </select>
            </div>
            <div class="control-group">
                <label>ì œê³µì—…ì²´</label>
                <select id="providerFilter" onchange="updateData()">
                    <option value="">ì „ì²´</option>
                </select>
            </div>
            <button onclick="exportData()">ğŸ“¤ CSV ë‚´ë³´ë‚´ê¸°</button>
        </div>

        <div id="loadingIndicator" class="loading">
            ğŸ“Š IndexedDBì—ì„œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
        </div>

        <div id="errorContainer"></div>

        <div id="dashboardContent" style="display: none;">
            <!-- ìš”ì•½ ì¹´ë“œ -->
            <div class="summary-cards">
                <div class="summary-card">
                    <div class="card-icon">ğŸ”„</div>
                    <div class="card-value" id="totalCalls">0</div>
                    <div class="card-title">ì´ í˜¸ì¶œ ìˆ˜</div>
                </div>
                <div class="summary-card">
                    <div class="card-icon">ğŸ¯</div>
                    <div class="card-value" id="totalTokens">0</div>
                    <div class="card-title">ì´ í† í° ìˆ˜</div>
                </div>
                <div class="summary-card">
                    <div class="card-icon">ğŸ’°</div>
                    <div class="card-value" id="totalCost">$0.00</div>
                    <div class="card-title">ì´ ë¹„ìš©</div>
                </div>
                <div class="summary-card">
                    <div class="card-icon">âš¡</div>
                    <div class="card-value" id="avgLatency">0ms</div>
                    <div class="card-title">í‰ê·  ì§€ì—°ì‹œê°„</div>
                </div>
                <div class="summary-card">
                    <div class="card-icon">âœ…</div>
                    <div class="card-value" id="successRate">100%</div>
                    <div class="card-title">ì„±ê³µë¥ </div>
                </div>
            </div>

            <!-- ì°¨íŠ¸ ì„¹ì…˜ -->
            <div class="charts-section">
                <div class="chart-container">
                    <div class="chart-title">ğŸ“ˆ ì‚¬ìš©ëŸ‰ íŠ¸ë Œë“œ</div>
                    <canvas id="trendChart"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">ğŸ¢ ì œê³µì—…ì²´ë³„ ë¶„í¬</div>
                    <canvas id="providerChart"></canvas>
                </div>
            </div>

            <!-- ìƒì„¸ ì •ë³´ ì„¹ì…˜ -->
            <div class="details-section">
                <div class="detail-card">
                    <div class="chart-title">ğŸ¯ ê¸°ëŠ¥ë³„ ì‚¬ìš©ëŸ‰</div>
                    <ul class="feature-list" id="featureList"></ul>
                </div>
                <div class="detail-card">
                    <div class="chart-title">ğŸ’° ë¹„ìš© ë¶„ì„</div>
                    <canvas id="costChart"></canvas>
                </div>
            </div>

            <!-- ìµœê·¼ ë¡œê·¸ í…Œì´ë¸” -->
            <div class="detail-card">
                <div class="chart-title">ğŸ“ ìµœê·¼ API í˜¸ì¶œ ë¡œê·¸</div>
                <table class="logs-table" id="logsTable">
                    <thead>
                        <tr>
                            <th>ì‹œê°„</th>
                            <th>ì œê³µì—…ì²´</th>
                            <th>ëª¨ë¸</th>
                            <th>ê¸°ëŠ¥</th>
                            <th>í† í°</th>
                            <th>ë¹„ìš©</th>
                            <th>ì§€ì—°ì‹œê°„</th>
                            <th>ìƒíƒœ</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>

            <!-- ë‚´ë³´ë‚´ê¸° ì„¹ì…˜ -->
            <div class="export-section">
                <div class="chart-title">ğŸ“¤ ë°ì´í„° ë‚´ë³´ë‚´ê¸°</div>
                <div class="export-buttons">
                    <button class="export-btn" onclick="exportToCSV()">ğŸ“Š CSV ë‹¤ìš´ë¡œë“œ</button>
                    <button class="export-btn" onclick="exportToJSON()">ğŸ“‹ JSON ë‹¤ìš´ë¡œë“œ</button>
                    <button class="export-btn" onclick="clearIndexedDB()">ğŸ—‘ï¸ ë°ì´í„° ì‚­ì œ</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // IndexedDB ê´€ë¦¬ í´ë˜ìŠ¤
        class IndexedDBManager {
            constructor() {
                this.dbName = 'ai-api-logs.db';
                this.dbVersion = 1;
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = () => {
                        // ëŒ€ì‹œë³´ë“œì—ì„œëŠ” ì½ê¸°ë§Œ í•˜ë¯€ë¡œ ìŠ¤í‚¤ë§ˆ ìƒì„± ë¶ˆí•„ìš”
                        reject(new Error('IndexedDB ë°ì´í„°ë² ì´ìŠ¤ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Obsidian í”ŒëŸ¬ê·¸ì¸ì„ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”.'));
                    };
                });
            }

            async getAllLogs() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['api_logs'], 'readonly');
                    const store = transaction.objectStore('api_logs');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getDailyStats(days = 30) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['daily_stats'], 'readonly');
                    const store = transaction.objectStore('daily_stats');
                    const index = store.index('date');
                    
                    const endDate = new Date();
                    const startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() - days);
                    
                    const range = IDBKeyRange.bound(
                        startDate.toISOString().split('T')[0],
                        endDate.toISOString().split('T')[0]
                    );
                    
                    const request = index.getAll(range);
                    
                    request.onsuccess = () => {
                        const stats = request.result;
                        const processedStats = this.processDailyStats(stats, days);
                        resolve(processedStats);
                    };
                    
                    request.onerror = () => reject(request.error);
                });
            }

            processDailyStats(stats, days) {
                // ì¼ë³„ë¡œ ê·¸ë£¹í™”
                const dailyData = {};
                
                // ë¹ˆ ë‚ ì§œë“¤ë„ ì´ˆê¸°í™”
                for (let i = 0; i < days; i++) {
                    const date = new Date();
                    date.setDate(date.getDate() - i);
                    const dateStr = date.toISOString().split('T')[0];
                    dailyData[dateStr] = {
                        period: this.formatDate(date),
                        totalCalls: 0,
                        totalTokens: 0,
                        totalCost: 0,
                        avgLatency: 0,
                        successRate: 100,
                        providers: {},
                        features: {}
                    };
                }
                
                // ì‹¤ì œ í†µê³„ ë°ì´í„° ì¶”ê°€
                stats.forEach(stat => {
                    if (!dailyData[stat.date]) {
                        dailyData[stat.date] = {
                            period: this.formatDate(new Date(stat.date)),
                            totalCalls: 0,
                            totalTokens: 0,
                            totalCost: 0,
                            avgLatency: 0,
                            successRate: 0,
                            providers: {},
                            features: {}
                        };
                    }
                    
                    const day = dailyData[stat.date];
                    day.totalCalls += stat.totalCalls;
                    day.totalTokens += stat.totalTokens;
                    day.totalCost += stat.totalCost;
                    day.avgLatency = stat.avgLatency; // ì´ë¯¸ í‰ê· ê°’
                    day.successRate = stat.successRate; // ì´ë¯¸ ë°±ë¶„ìœ¨
                    day.providers[stat.provider] = (day.providers[stat.provider] || 0) + stat.totalCalls;
                    
                    // ê¸°ëŠ¥ë³„ ì§‘ê³„
                    Object.entries(stat.features || {}).forEach(([feature, calls]) => {
                        day.features[feature] = (day.features[feature] || 0) + calls;
                    });
                });
                
                // ìµœì¢… ì •ë¦¬
                return Object.values(dailyData).map(day => ({
                    ...day,
                    topFeatures: Object.entries(day.features)
                        .map(([feature, calls]) => ({ feature, calls, cost: 0 }))
                        .sort((a, b) => b.calls - a.calls)
                        .slice(0, 5),
                    providerBreakdown: Object.entries(day.providers)
                        .map(([provider, calls]) => ({
                            provider,
                            calls,
                            percentage: day.totalCalls > 0 ? (calls / day.totalCalls) * 100 : 0
                        }))
                        .sort((a, b) => b.calls - a.calls)
                })).sort((a, b) => a.period.localeCompare(b.period));
            }

            formatDate(date) {
                return `${date.getMonth() + 1}/${date.getDate()}`;
            }

            async clearAllData() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['api_logs', 'daily_stats'], 'readwrite');
                    
                    const logsStore = transaction.objectStore('api_logs');
                    const statsStore = transaction.objectStore('daily_stats');
                    
                    const clearLogs = logsStore.clear();
                    const clearStats = statsStore.clear();
                    
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(transaction.error);
                });
            }
        }

        // ì „ì—­ ë³€ìˆ˜
        let dbManager = null;
        let currentData = [];
        let allLogs = [];
        let charts = {};

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', function() {
            initializeDashboard();
        });

        async function initializeDashboard() {
            try {
                dbManager = new IndexedDBManager();
                await dbManager.init();
                
                document.getElementById('connectionStatus').textContent = 'ì—°ê²°ë¨';
                document.getElementById('connectionStatus').className = 'source-status connected';
                
                await loadIndexedDBData();
            } catch (error) {
                console.error('IndexedDB ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                showError('IndexedDB ì—°ê²° ì‹¤íŒ¨: ' + error.message + '\n\nObsidian í”ŒëŸ¬ê·¸ì¸ì„ ë¨¼ì € ì‹¤í–‰í•˜ê³  AI APIë¥¼ ì‚¬ìš©í•´ë³´ì„¸ìš”.');
                
                document.getElementById('connectionStatus').textContent = 'ì—°ê²° ì‹¤íŒ¨';
                document.getElementById('connectionStatus').className = 'source-status disconnected';
            }
        }

        async function loadIndexedDBData() {
            if (!dbManager) {
                showError('IndexedDBê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            showLoading();
            hideError();

            try {
                // ëª¨ë“  ë¡œê·¸ ê°€ì ¸ì˜¤ê¸°
                allLogs = await dbManager.getAllLogs();
                
                if (allLogs.length === 0) {
                    hideLoading();
                    showError('ì €ì¥ëœ API ë¡œê·¸ê°€ ì—†ìŠµë‹ˆë‹¤.\n\nObsidianì—ì„œ AI ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ë©´ ë¡œê·¸ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.');
                    return;
                }

                // UI ì—…ë°ì´íŠ¸
                hideLoading();
                document.getElementById('controls').style.display = 'flex';
                document.getElementById('dashboardContent').style.display = 'block';
                
                // ì œê³µì—…ì²´ í•„í„° ì˜µì…˜ ì—…ë°ì´íŠ¸
                updateProviderFilter();
                
                // ë°ì´í„° ì²˜ë¦¬ ë° í‘œì‹œ
                await updateData();
                
                // ìµœê·¼ ë¡œê·¸ í…Œì´ë¸” ì—…ë°ì´íŠ¸
                updateLogsTable(allLogs.slice(-50).reverse()); // ìµœê·¼ 50ê°œ
                
                document.getElementById('lastUpdate').textContent = 
                    `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${new Date().toLocaleString()} (${allLogs.length}ê°œ ë¡œê·¸)`;

            } catch (error) {
                hideLoading();
                showError('ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨: ' + error.message);
                console.error('Error loading IndexedDB data:', error);
            }
        }

        function updateProviderFilter() {
            const providers = [...new Set(allLogs.map(log => log.provider))];
            const select = document.getElementById('providerFilter');
            
            // ê¸°ì¡´ ì˜µì…˜ ì œê±° (ì²« ë²ˆì§¸ "ì „ì²´" ì˜µì…˜ ì œì™¸)
            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }
            
            providers.forEach(provider => {
                const option = document.createElement('option');
                option.value = provider;
                option.textContent = provider.toUpperCase();
                select.appendChild(option);
            });
        }

        async function updateData() {
            const periodType = document.getElementById('periodType').value;
            const range = parseInt(document.getElementById('rangeSelect').value);
            const providerFilter = document.getElementById('providerFilter').value;

            try {
                let stats;
                if (periodType === 'daily') {
                    stats = await dbManager.getDailyStats(range);
                } else {
                    // ì£¼ê°„/ì›”ê°„ì€ ë¡œê·¸ì—ì„œ ì§ì ‘ ê³„ì‚°
                    stats = calculateStatsFromLogs(allLogs, periodType, range);
                }

                // ì œê³µì—…ì²´ í•„í„° ì ìš©
                if (providerFilter) {
                    stats = stats.map(stat => ({
                        ...stat,
                        // í•„í„°ëœ ì œê³µì—…ì²´ë§Œ í‘œì‹œí•˜ë„ë¡ ì¡°ì •
                        providerBreakdown: stat.providerBreakdown.filter(p => p.provider === providerFilter)
                    }));
                }

                currentData = stats;
                
                updateSummaryCards(stats);
                updateCharts(stats);
                updateFeatureList(stats);

            } catch (error) {
                console.error('Error updating data:', error);
                showError('ë°ì´í„° ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ' + error.message);
            }
        }

        function calculateStatsFromLogs(logs, periodType, range) {
            const now = new Date();
            const startDate = new Date(now);
            
            if (periodType === 'weekly') {
                startDate.setDate(startDate.getDate() - (range * 7));
            } else if (periodType === 'monthly') {
                startDate.setMonth(startDate.getMonth() - range);
            }

            // í•„í„°ë§
            const filteredLogs = logs.filter(log => {
                const logDate = new Date(log.timestamp);
                return logDate >= startDate;
            });

            // ê¸°ê°„ë³„ ê·¸ë£¹í™”
            const grouped = {};
            
            filteredLogs.forEach(log => {
                const date = new Date(log.timestamp);
                let key;

                if (periodType === 'weekly') {
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    key = weekStart.toISOString().split('T')[0];
                } else if (periodType === 'monthly') {
                    key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                }

                if (!grouped[key]) {
                    grouped[key] = {
                        period: formatPeriod(key, periodType),
                        totalCalls: 0,
                        totalTokens: 0,
                        totalCost: 0,
                        latencySum: 0,
                        successCount: 0,
                        features: {},
                        providers: {}
                    };
                }

                const group = grouped[key];
                group.totalCalls++;
                group.totalTokens += log.totalTokens || 0;
                group.totalCost += log.cost || 0;
                group.latencySum += log.latency || 0;
                if (log.success) group.successCount++;

                // ê¸°ëŠ¥ë³„ ì§‘ê³„
                if (!group.features[log.feature]) {
                    group.features[log.feature] = { calls: 0, cost: 0 };
                }
                group.features[log.feature].calls++;
                group.features[log.feature].cost += log.cost || 0;

                // ì œê³µì—…ì²´ë³„ ì§‘ê³„
                group.providers[log.provider] = (group.providers[log.provider] || 0) + 1;
            });

            // ìµœì¢… ì²˜ë¦¬
            return Object.values(grouped).map(group => ({
                period: group.period,
                totalCalls: group.totalCalls,
                totalTokens: group.totalTokens,
                totalCost: group.totalCost,
                avgLatency: group.totalCalls > 0 ? group.latencySum / group.totalCalls : 0,
                successRate: group.totalCalls > 0 ? (group.successCount / group.totalCalls) * 100 : 100,
                topFeatures: Object.entries(group.features)
                    .map(([feature, data]) => ({ feature, calls: data.calls, cost: data.cost }))
                    .sort((a, b) => b.calls - a.calls)
                    .slice(0, 5),
                providerBreakdown: Object.entries(group.providers)
                    .map(([provider, calls]) => ({
                        provider,
                        calls,
                        percentage: group.totalCalls > 0 ? (calls / group.totalCalls) * 100 : 0
                    }))
                    .sort((a, b) => b.calls - a.calls)
            })).sort((a, b) => a.period.localeCompare(b.period));
        }

        function formatPeriod(key, periodType) {
            if (periodType === 'weekly') {
                const date = new Date(key);
                const endDate = new Date(date);
                endDate.setDate(endDate.getDate() + 6);
                return `${date.getMonth() + 1}/${date.getDate()} ~ ${endDate.getMonth() + 1}/${endDate.getDate()}`;
            } else if (periodType === 'monthly') {
                const [year, month] = key.split('-');
                return `${year}ë…„ ${month}ì›”`;
            }
        }

        function updateSummaryCards(stats) {
            const totals = stats.reduce((acc, stat) => ({
                totalCalls: acc.totalCalls + stat.totalCalls,
                totalTokens: acc.totalTokens + stat.totalTokens,
                totalCost: acc.totalCost + stat.totalCost,
                avgLatency: acc.avgLatency + stat.avgLatency,
                successRate: acc.successRate + stat.successRate
            }), { totalCalls: 0, totalTokens: 0, totalCost: 0, avgLatency: 0, successRate: 0 });

            document.getElementById('totalCalls').textContent = totals.totalCalls.toLocaleString();
            document.getElementById('totalTokens').textContent = totals.totalTokens.toLocaleString();
            document.getElementById('totalCost').textContent = `${totals.totalCost.toFixed(4)}`;
            document.getElementById('avgLatency').textContent = `${Math.round(totals.avgLatency / (stats.length || 1))}ms`;
            document.getElementById('successRate').textContent = `${(totals.successRate / (stats.length || 1)).toFixed(1)}%`;
        }

        function updateCharts(stats) {
            updateTrendChart(stats);
            updateProviderChart(stats);
            updateCostChart(stats);
        }

        function updateTrendChart(stats) {
            const ctx = document.getElementById('trendChart').getContext('2d');
            
            if (charts.trend) {
                charts.trend.destroy();
            }

            charts.trend = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: stats.map(stat => stat.period),
                    datasets: [
                        {
                            label: 'í˜¸ì¶œ ìˆ˜',
                            data: stats.map(stat => stat.totalCalls),
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: 'ë¹„ìš© ($)',
                            data: stats.map(stat => stat.totalCost),
                            borderColor: '#fa709a',
                            backgroundColor: 'rgba(250, 112, 154, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'ê¸°ê°„'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'í˜¸ì¶œ ìˆ˜'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'ë¹„ìš© ($)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    }
                }
            });
        }

        function updateProviderChart(stats) {
            const ctx = document.getElementById('providerChart').getContext('2d');
            
            if (charts.provider) {
                charts.provider.destroy();
            }

            const providerTotals = {};
            stats.forEach(stat => {
                stat.providerBreakdown.forEach(provider => {
                    providerTotals[provider.provider] = (providerTotals[provider.provider] || 0) + provider.calls;
                });
            });

            const labels = Object.keys(providerTotals);
            const values = Object.values(providerTotals);
            const colors = ['#667eea', '#764ba2', '#4facfe', '#00f2fe', '#fa709a'];

            if (labels.length === 0) {
                // ë°ì´í„°ê°€ ì—†ì„ ë•Œ
                charts.provider = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['ë°ì´í„° ì—†ìŒ'],
                        datasets: [{
                            data: [1],
                            backgroundColor: ['#e5e7eb']
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        }
                    }
                });
                return;
            }

            charts.provider = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels.map(label => label.toUpperCase()),
                    datasets: [{
                        data: values,
                        backgroundColor: colors.slice(0, labels.length),
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        function updateCostChart(stats) {
            const ctx = document.getElementById('costChart').getContext('2d');
            
            if (charts.cost) {
                charts.cost.destroy();
            }

            charts.cost = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: stats.map(stat => stat.period),
                    datasets: [{
                        label: 'ë¹„ìš© ($)',
                        data: stats.map(stat => stat.totalCost),
                        backgroundColor: 'rgba(102, 126, 234, 0.8)',
                        borderColor: '#667eea',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'ë¹„ìš© ($)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        function updateFeatureList(stats) {
            const featureList = document.getElementById('featureList');
            featureList.innerHTML = '';

            const featureTotals = {};
            stats.forEach(stat => {
                stat.topFeatures.forEach(feature => {
                    if (!featureTotals[feature.feature]) {
                        featureTotals[feature.feature] = { calls: 0, cost: 0 };
                    }
                    featureTotals[feature.feature].calls += feature.calls;
                    featureTotals[feature.feature].cost += feature.cost || 0;
                });
            });

            const sortedFeatures = Object.entries(featureTotals)
                .sort(([,a], [,b]) => b.calls - a.calls)
                .slice(0, 10);

            if (sortedFeatures.length === 0) {
                const li = document.createElement('li');
                li.className = 'feature-item';
                li.innerHTML = '<span class="item-name">ë°ì´í„° ì—†ìŒ</span>';
                featureList.appendChild(li);
                return;
            }

            sortedFeatures.forEach(([feature, stats]) => {
                const li = document.createElement('li');
                li.className = 'feature-item';
                li.innerHTML = `
                    <span class="item-name">${feature}</span>
                    <span class="item-stats">
                        ${stats.calls}íšŒ<br>
                        ${stats.cost.toFixed(4)}
                    </span>
                `;
                featureList.appendChild(li);
            });
        }

        function updateLogsTable(logs) {
            const tbody = document.querySelector('#logsTable tbody');
            tbody.innerHTML = '';

            if (logs.length === 0) {
                const row = tbody.insertRow();
                row.innerHTML = '<td colspan="8" style="text-align: center; color: #999;">ë¡œê·¸ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤</td>';
                return;
            }

            logs.forEach(log => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${new Date(log.timestamp).toLocaleString()}</td>
                    <td>${log.provider?.toUpperCase() || 'N/A'}</td>
                    <td>${log.model || 'N/A'}</td>
                    <td>${log.feature || 'N/A'}</td>
                    <td>${(log.totalTokens || 0).toLocaleString()}</td>
                    <td>${(log.cost || 0).toFixed(4)}</td>
                    <td>${log.latency || 0}ms</td>
                    <td>
                        <span class="status-indicator ${log.success ? 'status-success' : 'status-error'}"></span>
                        ${log.success ? 'ì„±ê³µ' : 'ì‹¤íŒ¨'}
                    </td>
                `;
            });
        }

        async function exportToCSV() {
            if (!currentData || currentData.length === 0) {
                alert('ë‚´ë³´ë‚¼ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const headers = ['ê¸°ê°„', 'í˜¸ì¶œìˆ˜', 'í† í°ìˆ˜', 'ë¹„ìš©', 'í‰ê· ì§€ì—°ì‹œê°„', 'ì„±ê³µë¥ '];
            const rows = currentData.map(stat => [
                stat.period,
                stat.totalCalls,
                stat.totalTokens,
                stat.totalCost.toFixed(4),
                Math.round(stat.avgLatency),
                stat.successRate.toFixed(1)
            ]);

            const csvContent = [headers, ...rows]
                .map(row => row.map(cell => `"${cell}"`).join(','))
                .join('\n');

            downloadFile(csvContent, 'ai-api-usage-stats.csv', 'text/csv');
        }

        async function exportToJSON() {
            if (!allLogs || allLogs.length === 0) {
                alert('ë‚´ë³´ë‚¼ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const jsonContent = JSON.stringify(allLogs, null, 2);
            downloadFile(jsonContent, 'ai-api-usage-logs.json', 'application/json');
        }

        async function clearIndexedDB() {
            if (!dbManager) {
                alert('IndexedDBê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }

            const confirmed = confirm(
                'ì •ë§ë¡œ ëª¨ë“  IndexedDB ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n' +
                'ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìœ¼ë©°, Obsidian í”ŒëŸ¬ê·¸ì¸ì˜ ëª¨ë“  ë¡œê·¸ê°€ ì‚­ì œë©ë‹ˆë‹¤.'
            );

            if (!confirmed) return;

            try {
                await dbManager.clearAllData();
                
                // UI ë¦¬ì…‹
                allLogs = [];
                currentData = [];
                
                document.getElementById('dashboardContent').style.display = 'none';
                document.getElementById('controls').style.display = 'none';
                
                // ì°¨íŠ¸ ì •ë¦¬
                Object.values(charts).forEach(chart => {
                    if (chart) chart.destroy();
                });
                charts = {};
                
                alert('ëª¨ë“  ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                
                // í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨
                location.reload();
                
            } catch (error) {
                console.error('ë°ì´í„° ì‚­ì œ ì‹¤íŒ¨:', error);
                alert('ë°ì´í„° ì‚­ì œ ì‹¤íŒ¨: ' + error.message);
            }
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showLoading() {
            document.getElementById('loadingIndicator').style.display = 'block';
            document.getElementById('dashboardContent').style.display = 'none';
        }

        function hideLoading() {
            document.getElementById('loadingIndicator').style.display = 'none';
        }

        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="error">âŒ ${message.replace(/\n/g, '<br>')}</div>`;
        }

        function hideError() {
            document.getElementById('errorContainer').innerHTML = '';
        }

        // ì£¼ê¸°ì ìœ¼ë¡œ ë°ì´í„° ìƒˆë¡œê³ ì¹¨ (5ë¶„ë§ˆë‹¤)
        setInterval(() => {
            if (dbManager && allLogs.length > 0) {
                loadIndexedDBData();
            }
        }, 5 * 60 * 1000);
    </script>
</body>
</html>